<?php
defined('BASEPATH') OR exit('No direct script access allowed');

require_once APPPATH.'controllers/Base_controller.php';

class ImageProducer extends Base_Controller {

  public function __construct() {
    parent::__construct(0);
  }

  public function index() {
    $this->load->model('CloudStorageModel');
    $this->load->model('ImageModel');

    // Generate the uri (excluding static/image/)
    $numOfSegments = $this->uri->total_segments();
    $imageDirectory = '';
    for($i = 3; $i < $numOfSegments; $i++) {
      $imageDirectory .= $this->uri->segment($i);
      $imageDirectory .= '/';
    }
    $pathinfo = pathinfo($this->uri->uri_string());
    $imageDirectory .= $pathinfo['basename'];

    $imageObject = new ImageModel($imageDirectory);
    if ($this->CloudStorageModel->doesImageExist($imageObject->getCloudStoragePath())) {
      // We want to skip if this is a development environment
      if ($imageObject->isAutoGenerated() && ENVIRONMENT != 'development') {
        $this->redirectToCloudStorage($this->CloudStorageModel->getCloudStorageUrl($imageObject->getCloudStoragePath()));
        return;
      }
    } else if (!$imageObject->isAutoGenerated()) {
      log_message('error', 'Image DOESNT exists in cloud storage <---------------- '.$this->uri->uri_string());
      $this->show_404();
      return;
    }

    // Image doesn't exist and needs generating
    $this->generateImage($imageObject);
  }

  private function generateImage($imageObject) {
    log_message('error', '$width = '.$imageObject->getDesiredWidth());
    log_message('error', '$height = '.$imageObject->getDesiredHeight());
    log_message('error', '$density = '.$imageObject->getDesiredDensity());
    log_message('error', 'getOriginalStoragePath = '.$imageObject->getOriginalStoragePath());
    log_message('error', 'getCloudStoragePath = '.$imageObject->getCloudStoragePath());

    $originalObjectPath = $imageObject->getOriginalStoragePath();
    $generatedObjectPath = $imageObject->getCloudStoragePath();

    // Get the original image
    if ($this->CloudStorageModel->doesImageExist($originalObjectPath) == false) {
      // If the response is false we can't find the original image to resize
      log_message('error', 'ImageProducer: The origin img doesn\'t exist '.$originalObjectPath);
      $this->show_404();
      return;
    }

    // Resize the original image
    $directoryToCopyTo = $imageObject->getCloudStorageDirectory();
    if(!file_exists($directoryToCopyTo)) {
      $old = umask(0);
      mkdir($directoryToCopyTo, 0777, true);
      umask($old);
    }

    $localOriginalFilepath = 'generated/'.$originalObjectPath;
    if (!file_exists($localOriginalFilepath)) {
      // File doesn't exist locally so need to attempt a download of it
      $copyUrl = $this->CloudStorageModel->getCloudStorageUrl($originalObjectPath);
      copy($copyUrl, $localOriginalFilepath);
    }

    if (!file_exists($localOriginalFilepath)) {
      log_message('error', 'Problem seems to have occured when fetching the '.
        'original file: '.$localOriginalFilepath);
      $this->show_404();
      return;
    }

    log_message('error', '');
    log_message('error', '');
    log_message('error', '=================================================');

    // Original exists, so resize it and serve it
    $localResizedFilepath = $generatedObjectPath;
    $this->resizeImage(
      $imageObject->getDesiredWidth(),
      $imageObject->getDesiredHeight(),
      $imageObject->getDesiredDensity(),
      $localOriginalFilepath,
      $localResizedFilepath
    );

    // See if the resizing worked
    if(!file_exists($localResizedFilepath)) {
      log_message('error', 'Unable to find the resized image.');
      $this->show_404();
      return;
    }

    log_message('error', '=================================================');
    log_message('error', '');
    log_message('error', '');

    $this->CloudStorageModel->saveImage($generatedObjectPath, $localResizedFilepath);

    unlink($localResizedFilepath);

    $this->redirectToCloudStorage($this->CloudStorageModel->getCloudStorageUrl($generatedObjectPath));
  }

  private function resizeImage(
   $width, $height, $density, $originalFilepath, $resizedFilepath) {

    // Check for Image Magick
    if (!extension_loaded('imagick')) {
      log_message('error', 'imagick not installed');
      return;
    } else {
      $v = Imagick::getVersion();
      log_message('error', 'imagick installed version: '.$v['versionString']);
    }

    if($width == 0 && $height == 0) {
      log_message('error', 'Cannot resize image with both zero width and height');
      return;
    }

    log_message('error', '$originalFilepath: ' . $originalFilepath);
    $originalImage = new Imagick($originalFilepath);
    $originImageFormat = $originalImage->getImageFormat();
    log_message('error', 'Orig Filesize: ' . $originalImage->getImageLength());
    log_message('error', 'Orig format: ' . $originalImage->getImageFormat());


    $origImageDimens = $originalImage->getImageGeometry();
    $origImgWidth = $origImageDimens['width'];
    $origImgHeight = $origImageDimens['height'];
    $origImgRatio = $origImgWidth / $origImgHeight;

    $newWidth = $width * $density;
    $newHeight = $height * $density;
    $newImageRatio;

    if($newWidth == 0 || $newHeight == 0) {
      // If one variable is 0, maintain the aspect ratio
      $newImageRatio = $origImgRatio;

      if($newWidth == 0) {
        $newWidth = $newHeight * $newImageRatio;
      } else if($newHeight == 0){
        $newHeight = $newWidth / $newImageRatio;
      }
    } else {
      // Calculate new ratio based on provided width and height
      $newImageRatio = $newWidth / $newHeight;
    }

    if($newWidth > $origImgWidth || $newHeight > $origImgHeight) {
      // Image is too small, should maintain the desired image ratio
      // and thats it

      // TODO: If newImageRatio == oldImageRatio it means, the ratio isn't
      // cared about - so return the origin image.

      if($newWidth > $origImgWidth) {
        $newWidth = $origImgWidth;
        $newHeight = $newWidth / $newImageRatio;
      }

      if($newHeight > $origImgHeight) {
        $newHeight = $origImgHeight;
        $newWidth = $newHeight * $newImageRatio;
      }
    }


    $cropImageWidth = $origImgWidth;
    $cropImageHeight = $origImgWidth / $newImageRatio;
    if($newImageRatio < $origImgRatio) {
      // We have use the width ratio.
      $cropImageHeight = $origImgHeight;
      $cropImageWidth = $origImgHeight * $newImageRatio;
    }

    // center the crop
    $cropX = ($origImgWidth - $cropImageWidth) / 2;
    $cropY = ($origImgHeight - $cropImageHeight) / 2;

    if(false) {
      $originalImage->setImageFormat('webp');

      $originalImage->setImageAlphaChannel(imagick::ALPHACHANNEL_ACTIVATE);
      $originalImage->setBackgroundColor(new ImagickPixel('transparent'));
    }

    //$originalImage->stripImage();
    //$originalImage->cropImage($cropImageWidth, $cropImageHeight, $cropX, $cropY);
    //$originalImage->writeImage($resizedFilepath);
    //$originalImage->clear();
    //$originalImage->destroy();

    $newWidth = intval($newWidth);
    $newHeight = intval($newHeight);

    $cropImageWidth = intval($cropImageWidth);
    $cropImageHeight = intval($cropImageHeight);

    $originalImage->cropImage($cropImageWidth, $cropImageHeight, $cropX, $cropY);
    $originalImage->thumbnailImage($newWidth, $newHeight);
    $originalImage->stripImage();
    $originalImage->writeImage($resizedFilepath);
    $originalImage->clear();
    $originalImage->destroy();

    if(strtolower($originImageFormat) == 'png') {
      $crushedFilepath = $resizedFilepath.'-crushed';
      $pngCrushCmd = sprintf('pngcrush -brute "%s" "%s" 2>&1', $resizedFilepath, $crushedFilepath);
      log_message('error', 'Attempting to run: '.$pngCrushCmd);
      exec($pngCrushCmd, $pngCrushOutput, $exitCode);
      if ($exitCode !== 0) {
        log_message('error', '!!!!!!!!!!!!!!!!!!!!!!!!'.APPPATH);
        log_message('error', '!!!!!!!!!!!!!!!!!!!!!!!!');
        log_message('error', 'There was a problem running pngcrush: ');
        for($i = 0; $i < sizeof($pngCrushOutput); $i++) {
          log_message('error', '    '.$pngCrushOutput[$i]);
        }
        log_message('error', '!!!!!!!!!!!!!!!!!!!!!!!!');
      } else {
        log_message('error', 'PNGCrush successful');
        if(file_exists($crushedFilepath)) {
          log_message('error', 'Rename');
          unlink($resizedFilepath);
          rename($crushedFilepath, $resizedFilepath);
        }
      }
    }

    $finalStripVersionPath = $resizedFilepath.'-stripped';
    $resizedImage = new Imagick($resizedFilepath);
    $resizedFileLength = $resizedImage->getImageLength();
    log_message('error', 'Resized and Cropped Filesize: ' . $resizedImage->getImageLength());
    $resizedImage->stripImage();
    $resizedImage->writeImage($finalStripVersionPath);
    $resizedImage->clear();
    $resizedImage->destroy();

    $finalStrippedImage = new Imagick($finalStripVersionPath);
    $finalStrippedFileLength = $finalStrippedImage->getImageLength();
    log_message('error', 'Stripped Filesize: ' . $finalStrippedFileLength);
    $finalStrippedImage->clear();
    $finalStrippedImage->destroy();

    $finalFileSize = -1;
    if ($resizedFileLength < $finalStrippedFileLength) {
      unlink($finalStripVersionPath);
      $finalFileSize = $resizedFileLength;
    } else {
      unlink($resizedFilepath);
      rename($finalStripVersionPath, $resizedFilepath);

      $finalFileSize = $finalStrippedFileLength;
    }

    log_message('error', 'Final Filesize: ' . $finalFileSize);
  }

  private function redirectToCloudStorage($url) {
    $this->load->helper('url');

    $expiresSeconds = (30 * 24 * 60 * 60);
    $expiresTime = time() + $expiresSeconds;

    header("Cache-Control: public, must-revalidate, proxy-revalidate");
    header("Cache-Control: max-age=".$expiresSeconds, false);
    header('Expires: ' . gmdate('D, d M Y H:i:s', $expiresTime) . ' GMT');

    redirect($url, 'location', 301);
  }
}
